// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using XUtility;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace XSocketClient
{
    /// <summary>
    /// TCP wraper.
    /// </summary>
    public class TCPWraper:INet
    {   

        public static string Ip;

        public static int Port;

        private static ManualResetEvent mClientDone = new ManualResetEvent(false);
        #if UNITY_WP8
        private Socket socket;
        
        private SocketAsyncEventArgs sendSocketAsynEvnetArgs;
        
        private SocketAsyncEventArgs receiveSocketAsynEvnetArgs;

        private object receiveLock = new object();
        #else
        private TcpClient socket;
        #endif
        private bool connected;

        private LogWraper log;

        private ReceiveState receiveState;

        private CustomerAction<Int16, byte[]> eventCallback;

        private CustomerAction<int,Int16, byte[]> responeCallback;

        private CustomerAction<bool> connectStatus;

        private class ReceiveState
        {
            public List<byte[]> receiveBuff;
            public byte[] Buff;
            public Socket WorkSocket;
            private int index = 0;
            private List<byte> data;
            private int dataLength;

            public void ReceiveData(int count, int offset)
            {
                if (count < 1)
                    return;

                if (index == 0)
                {
                    dataLength = BitConvert.GetInt32(Buff, ref offset);

                    if (dataLength > count)
                    {
                        //not complete.
                    
                        //store
                        data = new List<byte>(dataLength);
                        for (int i = 0; i < count; i++)
                            data.Add(Buff [i]);
                        index = count;
                    } else
                    {
                        data = new List<byte>(dataLength);
                        for (int i = 0; i < count; i++)
                            data.Add(Buff [i]);
                        //handle
                        HandData(data, dataLength);

                        //next
                        index = 0;
                        data = null;
                        ReceiveData(count - dataLength, dataLength);
                    }
                } else
                {
                    if ((data.Count + count) >= dataLength)
                    {
                        int i;
                        for (i = 0, index = dataLength - data.Count; i < index; i++)
                            data.Add(Buff [i]);
                                                        
                        //handle
                        HandData(data, dataLength);
                        //next
                        index = 0;
                        data = null;
                        //ReceiveData(count - dataLength, dataLength);
                        if(count - i > 0)
                            ReceiveData(count - i, i);
                    } else
                    {
                        //story
                        for (int i = 0; i < count; i++)
                            data.Add(Buff [i]);
                        index += count;
                    }
                }
            }

            private void HandData(List<byte> value, int count)
            {
                if (value == null || value.Count != count)
                    return;

                byte[] ret = new byte[count - 24];
                for(int i = 0, max = count - 24; i < max; i++)
                    ret[i] = value[i + 24];
                receiveBuff.Add(ret);
            }

            public ReceiveState()
            {
                Buff = new byte[GlobalConstantNet.BufferMaxSize];
                receiveBuff = new List<byte[]>();
            }
        }

        #region INet implementation

        /// <summary>
        /// Gets a value indicating whether this <see cref="XSocketClient.TCPWraper"/> is connected.
        /// </summary>
        /// <value><c>true</c> if connected; otherwise, <c>false</c>.</value>
        public bool Connected
        {
            #if UNITY_WP8
            get{return connected && socket.Connected;}
            #else
            get{ return connected && socket.Connected;}
            #endif
        }

        /// <summary>
        /// Connect the specified ip and port.
        /// </summary>
        /// <param name="ip">Ip.</param>
        /// <param name="port">Port.</param>
        public bool Connect(string ip, int port)
        {
            ConnectASyn(ip, port, 2000);
            return true;
        }

        /// <summary>
        /// Disconnect this instance.
        /// </summary>
        public bool Disconnect()
        {
            if (socket == null || !connected)
                return true;
            
            connected = false;

            try
            {
                socket.Close();
            } catch (Exception e)
            {
                log.LogError(e.Message);
                return false;
            }
            
            if(connectStatus!= null)
                connectStatus(false);

            //release resource.
            socket = null;
            sendSocketAsynEvnetArgs = null;
            receiveSocketAsynEvnetArgs = null;
            return true;
        }

        /// <summary>
        /// Sends the request.
        /// </summary>
        /// <returns><c>true</c>, if request was sent, <c>false</c> otherwise.</returns>
        /// <param name="data">Data.</param>
        public bool SendRequest(IDataWraper data)
        {
            if (data == null || socket == null)
                return false;
            CustomerArray<byte> s = data.Serialization();
            if (s == null)
                return false;

//            byte[] buff = new byte[GlobalConstant.BufferMaxSize];
//            int start = 0;
//            start += BitConvert.MemeoryCopy(25 + s.Length, ref buff, start);
//            start += BitConvert.MemeoryCopy((Int16)1, ref buff, start);
//            start += BitConvert.MemeoryCopy(2, ref buff, start);
//            start += BitConvert.MemeoryCopy(-1, ref buff, start);
//            start += BitConvert.MemeoryCopy((UInt64)123456, ref buff, start);
//            start += BitConvert.MemeoryCopy((char)5, ref buff, start);
//            start += BitConvert.MemeoryCopy((char)1, ref buff, start);
//            start += BitConvert.MemeoryCopy((char)2, ref buff, start);

            CustomerArray<byte> buff = new CustomerArray<byte>();
            int start = 0;
            start += BitConvert.MemoryCopy(24 + s.CurrentLength, ref buff, start); //整个数据包的长度.
            start += BitConvert.MemoryCopy((Int16)1, ref buff, start); //消息版本号.
            start += BitConvert.MemoryCopy(2, ref buff, start); //消息序列号.
            start += BitConvert.MemoryCopy(Session.DialogId, ref buff, start); //会话ID.
            start += BitConvert.MemoryCopy((UInt64)Session.Uid, ref buff, start); //用户识别码.
            start += BitConvert.MemoryCopy((char)5, ref buff, start); //标记.
            start += BitConvert.MemoryCopy((char)0, ref buff, start); //选项长度.
            //start += BitConvert.MemoryCopy((char)2, ref buff, start); //选项.
            for (int i = 0; i < s.CurrentLength; i++)
            {
                buff [start + i] = (byte)s [i];
            }
            start += s.CurrentLength;
            if (connected)
            {
                try
                {
                    #if UNITY_WP8
                    if(sendSocketAsynEvnetArgs == null)
                        return false;
                    sendSocketAsynEvnetArgs.SetBuffer(buff.Data,0,start);
                    socket.SendAsync(sendSocketAsynEvnetArgs);
                    #else
                    socket.Client.Send(buff.Data, 0, start, SocketFlags.None);
                    #endif
                } catch (Exception e)
                {
                    log.LogError(e.Message);
                }
            }

            return true;
        }

        /// <summary>
        /// Handles the event.
        /// </summary>
        /// <param name="code">Code.</param>
        /// <param name="data">Data.</param>
        public void HandleEvent(Int16 code, byte[] data)
        {
            if(eventCallback != null)
                eventCallback(code,data);
        }

        /// <summary>
        /// Handles the response.
        /// </summary>
        /// <param name="returnCode">Return code.</param>
        /// <param name="code">Code.</param>
        /// <param name="data">Data.</param>
        public void HandleResponse(int returnCode, Int16 code, byte[] data)
        {
            if(responeCallback != null)
                responeCallback(returnCode, code, data);
        }

        
        Int16 msgId;
        Int16 msgType;
        Int16 returnCode;
        int tempOffset = 0;

        /// <summary>
        /// Update this instance.
        /// </summary>
        public void Update()
        {
            if (receiveState == null || receiveState.receiveBuff.Count < 1)
                return;

            for (int i = 0, max = receiveState.receiveBuff.Count; i < max; i++)
            {
                tempOffset = 0;
                msgId = BitConvert.GetInt16(receiveState.receiveBuff[i],ref tempOffset);
                msgType = BitConvert.GetInt16(receiveState.receiveBuff[i], ref tempOffset);
                if(msgType == GlobalConstantNet.MsgEvnet)
                {
                    HandleEvent(msgId, receiveState.receiveBuff[i]);
                }
                else if(msgType == GlobalConstantNet.MsgResponse)
                {
                    tempOffset = 18;
                    returnCode = BitConvert.GetInt16(receiveState.receiveBuff[i], ref tempOffset);
                    HandleResponse(returnCode,msgId, receiveState.receiveBuff[i]);
                }
                tempOffset = 0;
            }
            receiveState.receiveBuff.Clear();
        }
        #endregion

        /// <summary>
        /// Registers the response.
        /// </summary>
        /// <param name="handle">Handle.</param>
        public void RegisterResponse(CustomerAction<int, Int16, byte[]> handle)
        {
            responeCallback = handle;
        }

        /// <summary>
        /// Registers the connect status.
        /// </summary>
        /// <param name="status">Status.</param>
        public void RegisterConnectStatus(CustomerAction<bool> status)
        {
            connectStatus = status;
        }

        /// <summary>
        /// Registers the event.
        /// </summary>
        /// <param name="handle">Handle.</param>
        public void RegisterEvent(CustomerAction<Int16,byte[]> handle)
        {
            eventCallback = handle;
        }
        
        #if UNITY_WP8
        private void HandReceive(object sender, SocketAsyncEventArgs e)
        {
            lock(receiveLock)
            {
                if(e.SocketError == SocketError.Success)
                {
                    if(e.BytesTransferred > 0)
                    {
                        receiveState.Buff = e.Buffer;
                        receiveState.ReceiveData(e.BytesTransferred, e.Offset);
                        if(!receiveState.WorkSocket.ReceiveAsync(receiveSocketAsynEvnetArgs))
                        {
                            socket.ReceiveAsync(e);
                        }
                    }
                }
                else
                    Disconnect();
            }
        }
        #else
        private void HandReceive(IAsyncResult ar)
        {
            ReceiveState tem = (ReceiveState)ar.AsyncState;
            if (tem == null)
                return;

            int read = tem.WorkSocket.EndReceive(ar);

            if (read > 0)
            {
                tem.ReceiveData(read,0);
                tem.WorkSocket.BeginReceive(tem.Buff,0,GlobalConstantNet.BufferMaxSize,0, new AsyncCallback(HandReceive),tem);

            } else
            {
                connected = false;
                log.LogWarning("Disconnect By Server");
            }

        }
        #endif

        #region connect
        
        private bool ConnectSyn(string ip, int port)
        {
            #if UNITY_WP8
            IPEndPoint ipEP = new IPEndPoint(IPAddress.Parse(ip), port);
            
            if(socket == null)
            {
                socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            }
            SocketAsyncEventArgs socketEventArg = new SocketAsyncEventArgs();
            socketEventArg.RemoteEndPoint = ipEP;
            
            socketEventArg.Completed += new EventHandler<SocketAsyncEventArgs>(delegate(object sender, SocketAsyncEventArgs e) {
                if(e.SocketError == SocketError.Success)
                {
                    SetConnectOk();
                }
            });
            socket.ConnectAsync(socketEventArg);
            #else
            if (socket == null)
                socket = new TcpClient();
            try
            {
                socket.Connect(ip, port);
                connected = true;
                receiveState = new ReceiveState();
                receiveState.WorkSocket = socket.Client;
                socket.Client.BeginReceive(receiveState.Buff, 0, GlobalConstantNet.BufferMaxSize, 0, new AsyncCallback(HandReceive), receiveState);
            } catch (Exception e)
            {
                log.LogError(e.Message);
                connected = false;
                return false;
            }
            #endif
            return true;
        }
        
        private void ConnectASyn(string ip,Int32 port, Int32 timeOut)
        {
            
            mClientDone.Reset();
            #if UNITY_WP8
            IPEndPoint ipEP = new IPEndPoint(IPAddress.Parse(ip), port);
            
            if(socket == null)
            {
                socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            }
            SocketAsyncEventArgs socketEventArg = new SocketAsyncEventArgs();
            socketEventArg.RemoteEndPoint = ipEP;

            
            socketEventArg.Completed += new EventHandler<SocketAsyncEventArgs>(delegate(object sender, SocketAsyncEventArgs e) {
                if(e.SocketError == SocketError.Success)
                {
                  //  SetConnectOk();
                    
                    mClientDone.Set();
                }
                //mClientDone.Set();
            });
            socket.ConnectAsync(socketEventArg);
            #else
            socket.BeginConnect(ip, port, ConnectCallback, socket);
            #endif
            
            if (mClientDone.WaitOne(timeOut))
            {
                SetConnectOk();
            } else
            {
                if(connectStatus!= null)
                    connectStatus(false);
                connected = false;
                log.LogError("Connect timeout!");
            }
        }
        
        private void ConnectCallback(IAsyncResult ar)
        {
            #if UNITY_WP8
            #else
            mClientDone.Set();
            TcpClient t = (TcpClient)ar.AsyncState;
            t.EndConnect(ar);
            #endif
        }
        
        private void SetConnectOk()
        {
            connected = true;
            IPEndPoint ipe = socket.RemoteEndPoint as IPEndPoint;
            Ip = ipe.Address.ToString();
            Port = ipe.Port;
            receiveState = new ReceiveState();

            #if UNITY_WP8
            if(socket != null)
            {
                receiveState.WorkSocket = socket;
                if(receiveSocketAsynEvnetArgs == null)
                {
                    receiveSocketAsynEvnetArgs = new SocketAsyncEventArgs();
                    receiveSocketAsynEvnetArgs.RemoteEndPoint = socket.RemoteEndPoint;
                    receiveSocketAsynEvnetArgs.SetBuffer(new byte[GlobalConstantNet.BufferMaxSize],0,GlobalConstantNet.BufferMaxSize);
                    receiveSocketAsynEvnetArgs.Completed += new EventHandler<SocketAsyncEventArgs>(HandReceive);
                }
                socket.ReceiveAsync(receiveSocketAsynEvnetArgs);

                if(sendSocketAsynEvnetArgs == null)
                {
                    sendSocketAsynEvnetArgs = new SocketAsyncEventArgs();
                    sendSocketAsynEvnetArgs.RemoteEndPoint = socket.RemoteEndPoint;
                    sendSocketAsynEvnetArgs.Completed += new EventHandler<SocketAsyncEventArgs>(delegate(object sender, SocketAsyncEventArgs e) {
                        if(e.SocketError != SocketError.Success)
                        {
                            log.LogError("Send error!");
                            Disconnect();
                        }
                   });
                    sendSocketAsynEvnetArgs.UserToken = null;
                }
            }
            #else
            receiveState.WorkSocket = socket.Client;
            socket.Client.BeginReceive(receiveState.Buff, 0, GlobalConstantNet.BufferMaxSize, 0, new AsyncCallback(HandReceive), receiveState);
            #endif
            
            if(connectStatus!= null)
                connectStatus(true);
        }
        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="XSocketClient.TCPWraper"/> class.
        /// </summary>
        public TCPWraper()
        {
            #if UNITY_WP8
            #else
            socket = new TcpClient();
            #endif
            log = LogWraper.GetLog<TCPWraper>();
        }
    }
}

